Ответы на вопросы:

1. JSON к объектам из предыдущего дз

let magazineJson = `[{
    "name": "Vogue",
    "periodicity": "ежемесячно",
    "specializiatoin": "мода",
    "publishingHouse": "Condé Nast Publications",
    ]}`


    let scooter = `[{
        "manifacter": "ООО 'Самокат'",
        "name": "Лучший Самокатик",
        "model": "Y-100",
        "productionMaterial": "железо",
        "year": "2021",
        ]}`

    let furniture = `[{
        "factory": "ООО 'Мягкая мебель'",
        "name": "Мягкое кресло",
        "materialSurface": "велюр",
        "materialFrame": "дерево",
        "depth": "100см",
        "width": "110см",
        "height": "120см",
        "adressCustomer": "г.Москва",
        ]}`

методы обеъекта при преобразовании в строку JSON будут проигнорированы

2. Отличие JSON от XML

XML это открытый стандарт для хранения и обмена данными (позволяет авторам определять свой язык разметки и использовать его на любом сайте или в любом приложении). Это язык разметки для описания структуры и содержания любого XML файла, такого как документы, веб-страницы или базы данных. 

JSON vs XML: различия
1) JSON расшифровывается как JavaScript Object Notation. Это текстовый открытый стандартный формат обмена данными. JSON легкий и легко читаемый, но не предоставляет схем или информации о типах. Он отлично подходит для обмена данными между несколькими приложениями. XML означает расширяемый язык разметки. Это язык разметки, который определяет структуру любого файла XML в виде древовидной структуры.  Его можно использовать для обмена структурированной информацией между программами и документами.

2) JSON может использоваться с JavaScript или обычными текстовыми файлами, в то время как XML может храниться только в виде текстового файла. Кроме того, при обработке информации JSON использует меньше памяти, чем программа XML. 

3) XML сложнее, поскольку требует больше информации о структуре документа, прежде чем его можно будет прочитать.

4) Формат JSON используется для хранения и передачи данных, а XML - для представления данных в машиночитаемом виде. JSON набирает популярность как средство хранения данных для веб-приложений благодаря своей простоте. В отличие от него, XML все еще используется для передачи структурированных данных через Интернет.

5) Вы можете использовать JSON в своем веб-приложении или мобильном приложении, не беспокоясь о проблемах совместимости, поскольку он широко распространен в веб- и мобильных приложениях. XML имеет некоторые проблемы, когда речь идет о кросс-платформенной совместимости. Он не поддерживается многими языками программирования.

6) XML файлы требуют больше места для хранения, чем файлы JSON. 

7) JSON синтаксис более компактный, чем у XML. JSON синтаксис легче читать и писать.
Синтаксис JSON позволяет легко определять объекты, в отличие от более многословного способа работы с массивами или коллекциями в синтаксисе XML. 

8)  В JSON и XML тип данных значения кодируется как объект или элемент. В JSON в качестве типов данных поддерживаются только строки, числа, булевы и null. С другой стороны, в данных XML для описания данных XML могут использоваться многие другие типы, например, дата и время.

Если в целом, то JSON быстрее, потому что:

JSON формат имеет меньшую площадь, чем XML.
JSON имеет более простой синтаксис для редактирования и создания новых документов, что делает отладку ошибок в ваших данных более доступной.
JSON является более гибким, чем XML - его можно использовать во многих различных языках программирования, тогда как XML можно использовать одновременно только в одном языке программирования (обычно Java).

Согласно исследованию Национального института стандартов и технологий (NIST), XML является более безопасным, чем JSON.

пример пердставения в JSON:

`{ "Breed": "beagle",
    "Size": "large",
    "Colour": "orange",
    "Age": "6 years" }`

пример пердставения в XML: 

<?xml version="1.0" encoding="UTF-8" ?>
<root>
  <Breed>beagle</Breed>
  <Size>large</Size>
  <Colour>orange</Colour>
  <Age>6 years</Age>
</root>

3. Сериализация - JSON.stringify для преобразования объектов в JSON. Метод JSON.stringify берёт объект и преобразует его в строку. Полученная строка json называется JSON-форматированным или сериализованным объектом. Его можно отправить его по сети или поместить в обычное хранилище данных. Если  нужно отправить какие-то данные на сервер, то мы должны сначала упаковать их в строку JSON-формата (сериализовать) и только потом отправлять.

Десериализация (парсинг) - JSON.parse для преобразования JSON обратно в объект. Нужно, когда клиент получает в качестве ответа от сервера строку JSON и распаковывает (десериализует, парсит) её, т.е. превращает в JavaScript объект, и дале уже с этим объектом работает.

Можно вручную делать серилазицю и десериалиазцию, но проще воспользоватсья библиотекой JSON и ее методами JSON.stringify и JSON.parse.

Помимо работы с сервером сериализация и десериализация часто нужна для хранения и получения данных в веб-хранилищах (localStorage и sessionStorage).

4. Можно выбрать только один метод чтения ответа. Если мы уже получили ответ с response.text(), тогда response.json() не сработает, так как данные уже были обработаны.

5. В JS у нас есть операции, которые выполняются в фоновом/активном режиме, и поэтому наше веб-приложение не зависает каждый раз, когда оно ожидает пользовательское событие.

Тем не менее, иногда все должно проходить по порядку, иначе это вызовет хаос и неожиданные результаты. По этой причине мы можем использовать асинхронные вызовы, чтобы все работало как нужно.

6. Основные преимущества использования AJAX:

снижение трафика (из-за уменьшения объёма передаваемых данных между клиентом и сервером);
уменьшение нагрузки на сервер (не нужно генерировать всю страницу, а только ту часть, которую нужно обновить);
увеличение быстродействия и отзывчивости (нет необходимости в полной перезагрузки страницы, достаточно обновить содержимое только отдельных блоков);
повышение интерактивности (с помощью AJAX можно сразу отображать результаты и сделать ресурс более удобным для пользования).

7. fetch ('https://api.github.com/users/AlisaKovalFe')

8. Single Page Application (SPA) — архитектура, которая позволяет создавать гибкие веб-приложения с высокой скоростью работы.
Удобство SPA обусловлено тем, что это приложение открывается в любом браузере, как и обычный сайт. Но пользовательский опыт отличается. Посетитель при навигации по сайту фактически остаётся на одной странице, на которой по его запросу меняется контент. Это заметно ускоряет работу сайта.
SPA работает иначе: когда сайт впервые открывается, браузер загружает весь код веб-приложения. А если пользователь кликнет на ссылку, чтобы перейти к другой странице, то в браузер подгружается только новый контент и вся страница полностью не перезагружается.

Поскольку загрузка кода происходит один раз, обмен данными с сервером получается экономичным с точки зрения трафика. 

Плюсы и минусы SPA
SPA быстрые. Пользователи не ждут, когда загрузится очередная страница веб-приложения, а быстро получают контент.
Скорость выше и с точки зрения разработки. Неважно, многостраничный это сайт, лендинг, визитка или блог. SPA быстрее сверстать и запустить с использованием JavaScript-фреймворков. Для компании, где сидит больше одного разработчика, это выгодно.
SPA универсальные. Для работы сайта нужна только поддержка JavaScript в браузере. Проект проще масштабировать, можно даже использовать код веб-приложения для запуска мобильного приложения.
SPA гибкие. Архитектура подразумевает разделение на фронтенд и бэкенд.
Бэкендерам не нужно думать о том, как вывести данные для пользователей. Они концентрируются на бизнес-логике и работе с базой данных.
У фронтендеров появляется больше возможностей для управления сайтом. Например, они могут быстро и без костылей реализовать в интернет-магазине корзину неавторизованного пользователя или применение бонусной карты.
Минусы у SPA тоже есть.

Увеличивается трафик — пользователям приходится загружать больше на свои устройства.
Для разработки SPA требуются фронтендеры, а не верстальщики. Недостаточно накидать HTML-теги и стилизовать их. Нужно знать фреймворки и понимать, что происходит на сервере.